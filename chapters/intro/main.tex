\chapter{Introduction}
\label{ch:intro}
\section{Background}

IRs (Intermediary Representations) are used across different stages of compilation 
in order to work at different levels of abstraction. This allows high level 
optimizations to be applied on a high level view of the code, while letting low 
level optimizations (like instruction selection) be handled close to the ISA. 

One framework for working with IRs is MLIR (Multi-Level Intermediate Representation)
that has a collection of dialects that can be progressively lowered until assembly 
level language is reached.

One technique of interest is superoptimization. By leveraging formal semantics two 
separate programs can be proven equivalent, or in particular a target program can 
be proven to be a refinement of a source program. Therefore by enumerating all 
programs of a small size a shorter program we may find and then replace a larger 
one\textsuperscript{citation needed}.

This technique can be applied across IRs, in particular the target could even be an
ISA. This way we can use superoptimization to find lowerings from a source IR (like
LLVM IR) to an assembly language like RISC-V. Hence I'll refer to this as backend 
synthesis.

\section{Motivation}

Manually written backends are buggy, instruction selection is a hard problem, and 
most IRs (and even ISA) don't have readily available semantics with which the 
compiler developers can check correctness. Without automated tools for formal 
verification compiler developers will need to learn a new set of skills, and a large
amount of work would need to be done to ensure correctness of compiler backends.
\stefan{Here I would like an image regarding bug quantity over time}

There are existing verification tools that can prove the correctness of a lowering 
for which there are semantics available. \stefan{Here I'd link the paper on the smt 
dialect and it's use in verifying lowerings} However these require the compiler 
developer to both specify the semantics for their source and target representations, 
while also providing the lowering themselves. This is increases the overall amount 
of work required of the compiler developer.

Synthesizing a large portion of the backend from the bitvector semantics would only 
require the compiler expert to specify said semantics which can be done as a lowering 
to the SMT dialect\textsuperscript{[citation needed]} of MLIR. The synthesized method 
will also be formally verified so no more work will be required for correctness.

A second benefit of using superoptimization techniques is performance. Thus each 
instruction will be lowered into the minimal number of instructions. Lowerings can also
be synthesized for multiple input instructions, leading to a highly performant 
backend with little work from the programmer.

Thus this project introduces a prototype of backend synthesis to a subset RISC-V, 
evaluating its effectiveness, as well as some optimization techniques that can be 
applied to speed up the process, achieving more coverage of the source representation,
and a more performant backend, all while being proven correct.

\section{Approach}

For easier development, prototyping and experimenting I will be using the 
xDSL\textsuperscript{citation needed} framework which contains an implementation
of a RISC-V, as well as making use of the infrastructure in the open source project 
xdsl-smt, an implementation of SMTLib for xDSL, and mlir-fuzz, which is used for 
enumerating mlir programs. 

The project consists \stefan{WIP} of a series of contributions to these projects to add
the RISC-V dialect, lower it to the smt dialect and formally prove equivalence to some 
authoritative RISC-V semantics, enhance mlir-fuzz to generate RISC-V programs, then run
the enumerative synthesis, generating a backend for LLVM IR, evaluate the coverage and 
performance of the synthesized lowering.

Following this the aim is to experiment with various optimizations to increase synthesis
speed, increase coverage or performance.\stefan{Experiments and optimizations are WIP}

\section{Previous Work}
This project is based of work done by my supervisor Mathieu Fehr \stefan{there should
probably be more credits here} on xdsl-smt, and mlir-fuzz. It uses open source 
lean semantics\textsuperscript{citation needed} proven equivalent to the authoritative SAIL 
semantics\textsuperscript{citation needed}. 
Superoptimization is a well known technique utilized succesfully in projects such as
Souper\textsuperscript{citation needed}.
