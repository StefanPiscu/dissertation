\chapter{Introduction}
\label{ch:intro}

\section{Background}

\stefan{I'd like to define the terms IR, MLIR, Superoptimization, and synthesis before
I go onto motivation, as the reader may not be familiar with them}
IRs (Intermediary Representations) are used across different stages of compilation 
in order to work at different levels of abstraction. This allows high level 
optimizations to be applied on a high level view of the code, while letting low 
level optimizations (like instruction selection) be handled close to the ISA. 

One framework for working with IRs is MLIR (Multi-Level Intermediate Representation)
that has a collection of dialects that can be progressively lowered until assembly 
level language is reached.

One technique of interest is superoptimization. By leveraging formal semantics two 
separate programs can be proven equivalent, or in particular a target program can 
be proven to be a refinement of a source program. Therefore by enumerating all 
programs of a small size a shorter program we may find and then replace a larger 
one\textsuperscript{citation needed}.

This technique can be applied across IRs, in particular the target could even be an
ISA. This way we can use superoptimization to find lowerings from a source IR (like
LLVM IR) to an assembly language like RISC-V. Hence I'll refer to this as backend 
synthesis.

\section{Motivation}

Manually written backends are buggy, instruction selection is a hard problem, and 
most IRs (and even ISA) don't have readily available semantics with which the 
compiler developers can check correctness. Without automated tools for formal 
verification compiler developers will need to learn a new set of skills, and a large
amount of work would need to be done to ensure correctness of compiler backends.
\stefan{Here I would like an image regarding bug quantity over time}

There are existing verification tools that can prove the correctness of a lowering 
for which there are semantics available. \stefan{Here I'd link the paper on the smt 
dialect and it's use in verifying lowerings} However these require the compiler 
developer to both specify the semantics for their source and target representations, 
while also providing the lowering themselves. This is increases the overall amount 
of work required of the compiler developer.

Synthesizing a large portion of the backend from the bitvector semantics would only 
require the compiler expert to specify said semantics which can be done as a lowering 
to the SMT dialect\textsuperscript{[citation needed]} of MLIR. The synthesized method 
will also be formally verified so no more work will be required for correctness.

A second benefit of using superoptimization techniques is performance. Thus each 
instruction will be lowered into the minimal number of instructions. Lowerings can also
be synthesized for multiple input instructions, leading to a highly performant 
backend with little work from the programmer.

Thus this project introduces a prototype of backend synthesis to a subset RISC-V, 
evaluating its effectiveness, as well as some optimization techniques that can be 
applied to speed up the process, achieving more coverage of the source representation,
and a more performant backend, all while being proven correct.

\section{Approach}

For easier development, prototyping and experimenting I will be using the 
xDSL\textsuperscript{citation needed} framework which contains an implementation
of a RISC-V, as well as making use of the infrastructure in the open source project 
xdsl-smt, an implementation of SMTLib for xDSL, and mlir-fuzz, which is used for 
enumerating mlir programs. 

The project consists \stefan{WIP} of a series of contributions to these projects to add
the RISC-V dialect, lower it to the smt dialect and formally prove equivalence to some 
authoritative RISC-V semantics, enhance mlir-fuzz to generate RISC-V programs, then run
the enumerative synthesis, generating a backend for LLVM IR, evaluate the coverage and 
performance of the synthesized lowering.

Following this the aim is to experiment with various optimizations to increase synthesis
speed, increase coverage or performance.\stefan{Experiments and optimizations are WIP}

\section{Previous Work}
This project is based of work done by my supervisor Mathieu Fehr \stefan{there should
probably be more credits here} on xdsl-smt, and mlir-fuzz. It uses open source 
lean semantics\textsuperscript{citation needed} proven equivalent to the authoritative SAIL 
semantics\textsuperscript{citation needed}. 
Superoptimization is a well known technique utilized succesfully in projects such as
Souper\textsuperscript{citation needed}.


\clearpage
\chapter{Preparation}
\label{ch:prep}
\section{MLIR}
\subsection{RISC-V}
\subsection{LLVM IR}
\subsection{xDSL}
\subsection{IRDL}
\subsection{PDL}

\section{Semantics}
\subsection{SMT dialect}
\subsection{Refinements}
Poison.
\subsection{Translation Validation}

\section{Superoptimization}
\subsection{MLIR-fuzz}
\subsection{Lowering Synthesis}

\section{Formal Verification}
\subsection{Formal Specification of ISA Semantics}
\subsection{Proofs of Equivalence}

\section{Requirements Analysis}

This section should contain the requirements of the project, followed by a plan
to achieve those requirements within a real timeline.

There should be leftover time to iterate, optimize and experiment.

\section{Software Engineering}

\subsection{Development Model}
Spiral

\subsection{Languages and Tools}
Python, Pylance, MLIR, xDSL, xdsl-smt, mlir-fuzz, z3, Git, GitHub

\subsection{Open Source Contributions}
\section{Starting Point}
Knowledge of C++, Knowledge of Python

\clearpage
\chapter{Implementation}
\stefan{I think I need to add more content here. This should be my main focus after
completing some basic evaluation}
\label{ch:impl}
\section{Base RISC-V to SMT Semantics}
\subsection{Registers as MLIR Types}
\subsection{Immediates and Attributes}
\section{SMT to Lean4}
\subsection{Bitvector Operations}
\subsection{Generating theorems with bv\_decide}
\section{RISC-V Enumeration}
\subsection{RISC-V in IRDL}
\subsection{Synthetic Operations}
\section{Backend Synthesis}
\subsection{Refinements}
\subsection{Multithreaded Iterative Deepening}
I don't really know if the title works, here I'd talk about how I attempt to lower to lower
sizes first, and have a pool of workers do so in parallel.
\subsection{Conversion to PDL}
The functions obtained from the enumerative search are then converted into PDL Patterns.
\section{Pruning the searchspace}
This section will detail attempts at optimization that will hopefully succeed.
\section{Repository Overview}

\clearpage
\chapter{Evaluation}
\label{ch:eval}
\section{Correctness}

\subsection{Semantics correctness}
The semantics are proven equivalent to authoritative SAIL semantics in Lean.

\subsection{PDL Transformations}
The pdl transformations are proven equivalent using an smt solver.

\section{Synthesis duration analysis}

\subsection{Choosing Refinements}

\subsection{Effects of TBD optimization}

\section{Coverage of LLVM IR instructions}

\subsection{Base RISC-V instruction set}

\subsection{Bit Manipulation Extension}

\subsection{Multiplication and Division Extension}

\section{Performance against LLVM}




\clearpage
\chapter{Conclusion}
\label{ch:conc}

\section{Work Completed}

\subsection{Synthesized large chunk of LLVM to RISC-V Backend}

\subsection{Examined optimizations techniques for backend synthesis}

\subsection{Novel Contribution}
Here I don't know what to count as ``novel'' but hopefully there's
something I can write here.

\section{Future Work}
One thing I'll talk about here is making this a proper tool written in
a performance oriented language like C++.
More things as ideas arise.

\section{Reflections}
Waffling about things I learnt, with a focus on working on an open source
project, and how it's different from a personal project.

