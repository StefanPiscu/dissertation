\documentclass[12pt, a4paper, oneside]{book}

\newif\ifdraft
\drafttrue
\input{setup}

\addbibresource{refs.bib}

\newcommand{\myTitle}{Superoptimizing LLVM IR to RISC-V}
\newcommand{\myName}{Stefan-Constantin Piscu}
\newcommand{\myBGN}{2707D}
\newcommand{\myYear}{2026}
\newcommand{\myDate}{\today}

\begin{document}
\pagenumbering{roman}

\begin{titlepage}
    \raggedleft \myName \par
    \centering
    \vspace*{4cm}
    {\Huge \bfseries \myTitle \par}
    \ifdraft
    {\Huge \color{red} \bf DRAFT \par}
    \fi
    \vspace{2cm}
    {\Large Computer Science Tripos Part II \par}
    \vspace{1cm}
    {\Large \myYear \par}
\end{titlepage}


\newpage
\thispagestyle{plain}
\section*{Declaration}
I, the candidate for Part II of the Computer Science Tripos with Blind Grading Number \myBGN, hereby declare that this report and the work described in it are my own work, unaided except as may be specified below, and that the report does not contain material that has already been used to any substantial. In preparation of this report, I adhered to the Department of Computer Science and Technology AI Policy. [The project required the approved use of \textit{Insert AI Name if used} and such use is acknowledged in the text at the relevant sections.] I am content for my report to be made available to the students and staff of the University. 
\vspace{1cm}
\noindent Date: \myDate

\stefan{Here's an example comment}
\resolved[Stefan]{Here's an issue}{Here's a fix}
\include{proforma}

\tableofcontents

\clearpage
\pagenumbering{arabic}

\chapter{Introduction}
\label{ch:intro}
\section{Background}

IRs (Intermediary Representations) are used across different stages of compilation 
in order to work at different levels of abstraction. This allows high level 
optimizations to be applied on a high level view of the code, while letting low 
level optimizations (like instruction selection) be handled close to the ISA. 

One framework for working with IRs is MLIR (Multi-Level Intermediate Representation)
that has a collection of dialects that can be progressively lowered until assembly 
level language is reached.

One technique of interest is superoptimization. By leveraging formal semantics two 
separate programs can be proven equivalent, or in particular a target program can 
be proven to be a refinement of a source program. Therefore by enumerating all 
programs of a small size a shorter program we may find and then replace a larger 
one\textsuperscript{citation needed}.

This technique can be applied across IRs, in particular the target could even be an
ISA. This way we can use superoptimization to find lowerings from a source IR (like
LLVM IR) to an assembly language like RISC-V. Hence I'll refer to this as backend 
synthesis.

\section{Motivation}

Manually written backends are buggy, instruction selection is a hard problem, and 
most IRs (and even ISA) don't have readily available semantics with which the 
compiler developers can check correctness. Without automated tools for formal 
verification compiler developers will need to learn a new set of skills, and a large
amount of work would need to be done to ensure correctness of compiler backends.
\stefan{Here I would like an image regarding bug quantity over time}

There are existing verification tools that can prove the correctness of a lowering 
for which there are semantics available. \stefan{Here I'd link the paper on the smt 
dialect and it's use in verifying lowerings} However these require the compiler 
developer to both specify the semantics for their source and target representations, 
while also providing the lowering themselves. This is increases the overall amount 
of work required of the compiler developer.

Synthesizing a large portion of the backend from the bitvector semantics would only 
require the compiler expert to specify said semantics which can be done as a lowering 
to the SMT dialect\textsuperscript{[citation needed]} of MLIR. The synthesized method 
will also be formally verified so no more work will be required for correctness.

A second benefit of using superoptimization techniques is performance. Thus each 
instruction will be lowered into the minimal number of instructions. Lowerings can also
be synthesized for multiple input instructions, leading to a highly performant 
backend with little work from the programmer.

Thus this project introduces a prototype of backend synthesis to a subset RISC-V, 
evaluating its effectiveness, as well as some optimization techniques that can be 
applied to speed up the process, achieving more coverage of the source representation,
and a more performant backend, all while being proven correct.

\section{Approach}

For easier development, prototyping and experimenting I will be using the 
xDSL\textsuperscript{citation needed} framework which contains an implementation
of a RISC-V, as well as making use of the infrastructure in the open source project 
xdsl-smt, an implementation of SMTLib for xDSL, and mlir-fuzz, which is used for 
enumerating mlir programs. 

The project consists \stefan{WIP} of a series of contributions to these projects to add
the RISC-V dialect, lower it to the smt dialect and formally prove equivalence to some 
authoritative RISC-V semantics, enhance mlir-fuzz to generate RISC-V programs, then run
the enumerative synthesis, generating a backend for LLVM IR, evaluate the coverage and 
performance of the synthesized lowering.

Following this the aim is to experiment with various optimizations to increase synthesis
speed, increase coverage or performance.\stefan{Experiments and optimizations are WIP}

\section{Previous Work}
This project is based of work done by my supervisor Mathieu Fehr \stefan{there should
probably be more credits here} on xdsl-smt, and mlir-fuzz. It uses open source 
lean semantics\textsuperscript{citation needed} proven equivalent to the authoritative SAIL 
semantics\textsuperscript{citation needed}. 
Superoptimization is a well known technique utilized succesfully in projects such as
Souper\textsuperscript{citation needed}.


\clearpage
\chapter{Preparation}
\label{ch:prep}
\section{MLIR}
\subsection{RISC-V}
\subsection{LLVM IR}
\subsection{xDSL}
\subsection{IRDL}
\subsection{PDL}

\section{Semantics}
\subsection{SMT dialect}
\subsection{Refinements}
Poison.
\subsection{Translation Validation}

\section{Superoptimization}
\subsection{MLIR-fuzz}
\subsection{Lowering Synthesis}

\section{Formal Verification}
\subsection{Formal Specification of ISA Semantics}
\subsection{Proofs of Equivalence}

\section{Requirements Analysis}

This section should contain the requirements of the project, followed by a plan
to achieve those requirements within a real timeline.

There should be leftover time to iterate, optimize and experiment.

\section{Software Engineering}

\subsection{Development Model}
Spiral

\subsection{Languages and Tools}
Python, Pylance, MLIR, xDSL, xdsl-smt, mlir-fuzz, Git, GitHub

\subsection{Open Source Contributions}
\section{Starting Point}
Knowledge of C++, Knowledge of Python

\clearpage
\chapter{Implementation}
\label{ch:impl}
Implementation

\clearpage
\chapter{Evaluation}
\label{ch:eval}
Evaluation

\clearpage
\chapter{Conclusion}
\label{ch:conc}
Conclusion

\printbibliography
\end{document}